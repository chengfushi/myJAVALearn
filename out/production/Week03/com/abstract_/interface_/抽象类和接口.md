# 1抽象类

## 1.1引出

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法,那么这个类就是抽象类。

所谓抽象方法就是没有实现的方法，所谓没有实现就是指，没有方法体。

**当一个类中存在抽象方法时，需要将该类声明为abstract 类**，一般来说，抽象类会被继承，由其子类来实现抽象方法。

```java
abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }
    public abstract void eat()  ;
}
```

## 1.2抽象类的介绍

1)用abstract关键字来修饰一个类时,这个类就叫抽象类访问修饰符

2)用abstract关键字来修饰一个方法时,这个方法就是抽象方法

```java
访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体
```

3)抽象类的价值更多作用是在于设计,是设计者设计好后，让子类继承并实现抽象类。

4)抽象类是考官比较爱问的知识点，在框架和设计模式使用较多。

## 1.3抽象类使用的注意事项和细节讨论

1)**抽象类不能被实例化**

2)抽象类不一定要包含abstract方法。也就是说, 抽象类可以没有abstract方法。

3)一旦类包含了abstract方法,则这个类必须声明为abstract。

4)**abstract只能修饰类和方法，不能修饰属性和其它的。**

5)抽象类可以有任意成员【抽象类本质还是类】，比如: 非抽象方法、构造器、静态属性等等。

6)**抽象方法不能有主体，即不能实现**。

7)**如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。**

8)抽象方法不能使用private、final和 static来修饰，因为这些关键字都是和重写相违背的。

# 2.抽象类最佳实践-模板设计模式

## 2.1基本介绍

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

## 2.2模板设计模式能解决的问题

1)当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
2)编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式.

## 2.3最佳实践

需求：

有多个类，完成不同的任务job

要求统计得到各自完成任务的时间

```java
package com.hspedu.abstract_;

abstract public class Template { //抽象类-模板设计模式

    public abstract void job();//抽象方法

    public void calculateTime() {//实现方法，调用job方法
        //得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
        //得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println("任务执行时间 " + (end - start));
    }
}
```

以上就是把不确定的部分暴露出去，让子类去实现。

# 3.接口

## 3.1基本介绍

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：

```java
interface 接口名{
    //属性
    //抽象方法（接口中可以省略abstract关键字）（在jdk8后还可以有静态方法和默认方法）
}

class 类名 implements 接口 {
    // 自己属性;
    // 自己方法;
    // 必须实现的接口的抽象方法
}
```

小结:

接口是更加抽象的类。抽象类里的方法可以有方法体，接口里的所有方法都没有方法体(jdk7.0)。接口体现了程序设计的多态和高内聚低偶合的设计思想。

> 特别说明:Jdk8.0后接口类可以有静态方法（static），默认方法（default），也就是说接口中可以有方法的具体实现入。

## 3.2深入讨论

说现在有一个项目经理(段玉),管理三个程序员,功能开发一个软件.为了控制和管理软件,项目经理可以定义一些接口，然后由程序员具体实现。

通过接口，不仅可以统一方法名，同时在调用时只需要根据接口识别即可。

```java
package com.hspedu.interface_;

public interface DBInterface { //项目经理

    public void connect();//连接方法
    public void close();//关闭连接
}
```

```java
package com.hspedu.interface_;
//A程序
public class MysqlDB implements DBInterface {
    @Override
    public void connect() {
        System.out.println("连接mysql");
    }

    @Override
    public void close() {
        System.out.println("关闭mysql");
    }
}
```

```java
package com.hspedu.interface_;

//B程序员连接Oracle
public class OracleDB implements DBInterface{

    @Override
    public void connect() {
        System.out.println("连接oracle");
    }

    @Override
    public void close() {
        System.out.println("关闭oracle");
    }
}
```

```java
package com.hspedu.interface_;

public class Interface03 {
    public static void main(String[] args) {

        MysqlDB mysqlDB = new MysqlDB();
        t(mysqlDB);
        OracleDB oracleDB = new OracleDB();
        t(oracleDB);
    }

    public static void t(DBInterface db) {
        db.connect();
        db.close();
    }
}
```

## 3.3注意事项和细节

1) 接口不能被实例化（new）

2) 接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修
   饰。void aaa(); 实际上是abstract void aa();（同理，不写public也是默认public方法，因此实现时该方法不写public会报错。）

3) 一个普通类实现接口,就必须将该接口的所有方法都实现。

4) 抽象类实现接口，可以不用实现接口的方法。

5) **一个类同时可以实现多个接口**。
   
   ```java
   class Timer implements IA, IB{ }
   ```

6) **接口中的属性，只能是final的，而且是 public static final修饰符**。比如:int a=1;实际上是public static final int a=1; (必须初始化)

7) 接口中属性的访问形式:接口名.属性名

8) 接口不能继承其它的类,但是可以继承多个别的接口。（接口无法实现接口）
   
   ```java
   interface A extends B,C{}
   ```

9) 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。

## 3.4实现接口VS继承类

当子类继承了父类，就自动的拥有父类的功能，如果子类需要扩展功能，可以通过实现接口的方式扩展。可以理解 实现接口 是对 java 单继承机制的一种补充。

1. 接口和继承解决的问题不同
   
   继承的价值主要在于:解决代码的复用性和可维护性。

2. 接口的价值主要在于:设计，设计好各种规范(方法)，让其它类去实现这些方法。即更加的灵活

接口比继承更加灵活：继承是满足is - a的关系，而接口只需满足 like - a的关系。

**接口在一定程度上实现代码解耦[即:接口规范性+动态绑定机制]**

## 3.5接口的多态特性

1. 多态参数
   
   在前面的Usb接口案例，UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态(接口引用可以指向实现了接口的类的对象)。
   
   ```java
   package com.hspedu.interface_;
   
   public class InterfacePolyParameter {
       public static void main(String[] args) {
   
           //接口的多态体现
           //接口类型的变量 if01 可以指向 实现了IF接口类的对象实例
           IF if01 = new Monster();
           if01 = new Car();
   
           // 继承体现的多态
           // 父类类型的变量 a 可以指向 继承AAA的子类的对象实例
           AAA a = new BBB();
           a = new CCC();
       }
   }
   
   interface IF {}
   class Monster implements IF{}
   class Car implements  IF{}
   
   class AAA {
   
   }
   class BBB extends AAA {}
   class CCC extends AAA {}
   ```

```
2. 多态数组

演示一个案例:给**Usb数组中，存放 Phone 和相机对象**，Phone类还有一个特有的方法call()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法call。

```java
package com.hspedu.interface_;

public class InterfacePolyArr {
    public static void main(String[] args) {

        //多态数组 -> 接口类型数组
        Usb[] usbs = new Usb[2];
        usbs[0] = new Phone_();
        usbs[1] = new Camera_();
        /*
        给Usb数组中，存放 Phone 和 相机对象，Phone类还有一个特有的方法call（），
        请遍历Usb数组，如果是Phone对象，除了调用Usb 接口定义的方法外，
        还需要调用Phone 特有方法 call
         */
        for(int i = 0; i < usbs.length; i++) {
            usbs[i].work();//动态绑定..
            //和前面一样，我们仍然需要进行类型的向下转型
            if(usbs[i] instanceof Phone_) {//判断他的运行类型是 Phone_
                ((Phone_) usbs[i]).call();
            }
        }
    }
}

interface Usb{
    void work();
}
class Phone_ implements Usb {
    public void call() {
        System.out.println("手机可以打电话...");
    }

    @Override
    public void work() {
        System.out.println("手机工作中...");
    }
}
class Camera_ implements Usb {

    @Override
    public void work() {
        System.out.println("相机工作中...");
    }
}
```

3. 接口存在多态传递现象
   
   ```java
   package com.hspedu.interface_;
   
   /**
    * 演示多态传递现象
    */
   public class InterfacePolyPass {
       public static void main(String[] args) {
           //接口类型的变量可以指向，实现了该接口的类的对象实例
           IG ig = new Teacher();
           //如果IG 继承了 IH 接口，而Teacher 类实现了 IG接口
           //那么，实际上就相当于 Teacher 类也实现了 IH接口.
           //这就是所谓的 接口多态传递现象.
           IH ih = new Teacher();
       }
   }
   
   interface IH {
       void hi();
   }
   interface IG extends IH{ }
   class Teacher implements IG {
       @Override
       public void hi() {
       }
   }
   ```